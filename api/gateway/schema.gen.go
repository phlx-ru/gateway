// Package gateway provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package gateway

import (
	"fmt"
	"net/http"

	externalRef0 "gateway/api/gateway/auth"
	externalRef1 "gateway/api/gateway/common"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/gin-gonic/gin"
)

// GetAuthCheckParams defines parameters for GetAuthCheck.
type GetAuthCheckParams struct {
	// Auth token from Query
	AuthToken *externalRef1.AuthTokenInQuery `form:"authToken,omitempty" json:"authToken,omitempty"`

	// Auth token from Headers
	XAuthToken *externalRef1.AuthTokenInHeaders `json:"x-auth-token,omitempty"`
}

// PostAuthLoginJSONBody defines parameters for PostAuthLogin.
type PostAuthLoginJSONBody = externalRef0.LoginRequestBody

// PostAuthLoginJSONRequestBody defines body for PostAuthLogin for application/json ContentType.
type PostAuthLoginJSONRequestBody = PostAuthLoginJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /api/1/auth/check)
	GetAuthCheck(c *gin.Context, params GetAuthCheckParams)

	// (POST /api/1/auth/login)
	PostAuthLogin(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(c *gin.Context)

// GetAuthCheck operation middleware
func (siw *ServerInterfaceWrapper) GetAuthCheck(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthCheckParams

	// ------------- Optional query parameter "authToken" -------------
	if paramValue := c.Query("authToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "authToken", c.Request.URL.Query(), &params.AuthToken)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter authToken: %s", err)})
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "x-auth-token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-auth-token")]; found {
		var XAuthToken externalRef1.AuthTokenInHeaders
		n := len(valueList)
		if n != 1 {
			c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Expected one value for x-auth-token, got %d", n)})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-auth-token", runtime.ParamLocationHeader, valueList[0], &XAuthToken)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter x-auth-token: %s", err)})
			return
		}

		params.XAuthToken = &XAuthToken

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetAuthCheck(c, params)
}

// PostAuthLogin operation middleware
func (siw *ServerInterfaceWrapper) PostAuthLogin(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.PostAuthLogin(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) *gin.Engine {
	return RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router *gin.Engine, si ServerInterface, options GinServerOptions) *gin.Engine {
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	router.GET(options.BaseURL+"/api/1/auth/check", wrapper.GetAuthCheck)

	router.POST(options.BaseURL+"/api/1/auth/login", wrapper.PostAuthLogin)

	return router
}
