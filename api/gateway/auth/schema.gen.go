// Package auth provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package auth

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	externalRef0 "gateway/api/gateway/common"

	"github.com/getkin/kin-openapi/openapi3"
)

// ChangePasswordRequestBody defines model for changePasswordRequestBody.
type ChangePasswordRequestBody struct {
	// Пароль пользователя — от 8 до 255 символов
	NewPassword PropertyPassword `json:"newPassword" validate:"required,min=8,max=255"`

	// Пароль пользователя — от 8 до 255 символов
	OldPassword PropertyPassword `json:"oldPassword" validate:"required,min=8,max=255"`

	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// CheckResponse defines model for checkResponse.
type CheckResponse struct {
	// Данные авторизационной сессии
	Session struct {
		// Возможный DeviceID если запрос пришёл от мобильного устройства
		DeviceId *PropertyDeviceId `json:"deviceId,omitempty"`

		// IP-адрес
		Ip *PropertyIP `json:"ip,omitempty"`

		// Время по UTC, до которого сессия активна
		Until PropertySessionUntil `json:"until"`

		// User-Agent
		UserAgent *PropertyUserAgent `json:"userAgent,omitempty"`
	} `json:"session"`

	// Данные об авторизованном пользователе
	User struct {
		// Отображаемое имя пользователя
		DisplayName PropertyUserDisplayName `json:"displayName"`

		// Электронная почта
		Email *PropertyUserEmail `json:"email,omitempty"`

		// Уникальный идентификатор пользователя
		Id *PropertyUserId `json:"id,omitempty"`

		// Российский номер мобильного телефона в формате 9009009090
		Phone *PropertyUserPhoneTyped `json:"phone,omitempty"`

		// Тип пользователя из набора (admin|dispatcher|driver)
		Type PropertyUserType `json:"type"`
	} `json:"user"`
}

// GenerateCodeRequestBody defines model for generateCodeRequestBody.
type GenerateCodeRequestBody struct {
	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// LoginByCodeRequestBody defines model for loginByCodeRequestBody.
type LoginByCodeRequestBody struct {
	// Одноразовый код авторизации
	Code PropertyCode `json:"code" validate:"required,min=3,max=255"`

	// Опция "Запомнить меня" — сохранять ли авторизационную сессию надолго
	Remember *PropertyRemember `form:"remember" json:"remember,omitempty" validate:"omitempty,boolean"`

	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// LoginRequestBody defines model for loginRequestBody.
type LoginRequestBody struct {
	// Пароль пользователя — от 8 до 255 символов
	Password PropertyPassword `json:"password" validate:"required,min=8,max=255"`

	// Опция "Запомнить меня" — сохранять ли авторизационную сессию надолго
	Remember *PropertyRemember `form:"remember" json:"remember,omitempty" validate:"omitempty,boolean"`

	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// LoginResponse defines model for loginResponse.
type LoginResponse struct {
	// Авторизационный токен для пользовательской сессии
	Token externalRef0.PropertyAuthToken `json:"token"`

	// Время по UTC, до которого сессия активна
	Until PropertySessionUntil `json:"until"`
}

// NewPasswordRequestBody defines model for newPasswordRequestBody.
type NewPasswordRequestBody struct {
	// Пароль пользователя — от 8 до 255 символов
	Password PropertyPassword `json:"password" validate:"required,min=8,max=255"`

	// Код сброса пароля
	PasswordResetHash PasswordResetHash `json:"passwordResetHash" validate:"required,min=3,max=255"`

	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// Код сброса пароля
type PasswordResetHash = string

// Одноразовый код авторизации
type PropertyCode = string

// Возможный DeviceID если запрос пришёл от мобильного устройства
type PropertyDeviceId = string

// IP-адрес
type PropertyIP = string

// Пароль пользователя — от 8 до 255 символов
type PropertyPassword = string

// Опция "Запомнить меня" — сохранять ли авторизационную сессию надолго
type PropertyRemember = bool

// Время по UTC, до которого сессия активна
type PropertySessionUntil = time.Time

// User-Agent
type PropertyUserAgent = string

// Отображаемое имя пользователя
type PropertyUserDisplayName = string

// Электронная почта
type PropertyUserEmail = string

// Уникальный идентификатор пользователя
type PropertyUserId = int

// Российский номер мобильного телефона в формате 9009009090
type PropertyUserPhoneTyped = string

// Тип пользователя из набора (admin|dispatcher|driver)
type PropertyUserType = string

// Номер телефона (в произвольной форме) или адрес электронной почты
type PropertyUsername = string

// ResetPasswordRequestBody defines model for resetPasswordRequestBody.
type ResetPasswordRequestBody struct {
	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// Возможный DeviceID если запрос пришёл от мобильного устройства
type DeviceId = PropertyDeviceId

// IP-адрес
type Ip = PropertyIP

// User-Agent
type UserAgent = PropertyUserAgent

// CheckResponseOK defines model for checkResponseOK.
type CheckResponseOK = CheckResponse

// LoginResponseOK defines model for loginResponseOK.
type LoginResponseOK = LoginResponse

// Данные отсутствуют
type ResponseNoContent = interface{}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"cwXOZuoRjuhBGZXf3/9vAAAA//+pGGVtWBoAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "../common/schema.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
