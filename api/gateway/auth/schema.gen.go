// Package auth provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package auth

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	externalRef0 "gateway/api/gateway/common"

	"github.com/getkin/kin-openapi/openapi3"
)

// ChangePasswordRequestBody defines model for changePasswordRequestBody.
type ChangePasswordRequestBody struct {
	// Пароль пользователя — от 8 до 255 символов
	NewPassword PropertyPassword `json:"newPassword" validate:"required,min=8,max=255"`

	// Пароль пользователя — от 8 до 255 символов
	OldPassword PropertyPassword `json:"oldPassword" validate:"required,min=8,max=255"`

	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// CheckResponse defines model for checkResponse.
type CheckResponse struct {
	// Данные авторизационной сессии
	Session struct {
		// Возможный DeviceID если запрос пришёл от мобильного устройства
		DeviceId *PropertyDeviceId `json:"deviceId,omitempty"`

		// IP-адрес
		Ip *PropertyIP `json:"ip,omitempty"`

		// Время по UTC, до которого сессия активна
		Until PropertySessionUntil `json:"until"`

		// User-Agent
		UserAgent *PropertyUserAgent `json:"userAgent,omitempty"`
	} `json:"session"`

	// Данные об авторизованном пользователе
	User struct {
		// Отображаемое имя пользователя
		DisplayName PropertyUserDisplayName `json:"displayName"`

		// Электронная почта
		Email *PropertyUserEmail `json:"email,omitempty"`

		// Российский номер мобильного телефона в формате 9009009090
		Phone *PropertyUserPhoneTyped `json:"phone,omitempty"`

		// Тип пользователя из набора (admin|dispatcher|driver)
		Type PropertyUserType `json:"type"`
	} `json:"user"`
}

// GenerateCodeRequestBody defines model for generateCodeRequestBody.
type GenerateCodeRequestBody struct {
	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// LoginByCodeRequestBody defines model for loginByCodeRequestBody.
type LoginByCodeRequestBody struct {
	// Одноразовый код авторизации
	Code PropertyCode `json:"code" validate:"required,min=3,max=255"`

	// Опция "Запомнить меня" — сохранять ли авторизационную сессию надолго
	Remember *PropertyRemember `form:"remember" json:"remember,omitempty" validate:"omitempty,boolean"`

	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// LoginRequestBody defines model for loginRequestBody.
type LoginRequestBody struct {
	// Пароль пользователя — от 8 до 255 символов
	Password PropertyPassword `json:"password" validate:"required,min=8,max=255"`

	// Опция "Запомнить меня" — сохранять ли авторизационную сессию надолго
	Remember *PropertyRemember `form:"remember" json:"remember,omitempty" validate:"omitempty,boolean"`

	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// LoginResponse defines model for loginResponse.
type LoginResponse struct {
	// Авторизационный токен для пользовательской сессии
	Token externalRef0.PropertyAuthToken `json:"token"`

	// Время по UTC, до которого сессия активна
	Until PropertySessionUntil `json:"until"`
}

// NewPasswordRequestBody defines model for newPasswordRequestBody.
type NewPasswordRequestBody struct {
	// Пароль пользователя — от 8 до 255 символов
	Password PropertyPassword `json:"password" validate:"required,min=8,max=255"`

	// Код сброса пароля
	PasswordResetHash PasswordResetHash `json:"passwordResetHash" validate:"required,min=3,max=255"`

	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// Код сброса пароля
type PasswordResetHash = string

// Одноразовый код авторизации
type PropertyCode = string

// Возможный DeviceID если запрос пришёл от мобильного устройства
type PropertyDeviceId = string

// IP-адрес
type PropertyIP = string

// Пароль пользователя — от 8 до 255 символов
type PropertyPassword = string

// Опция "Запомнить меня" — сохранять ли авторизационную сессию надолго
type PropertyRemember = bool

// Время по UTC, до которого сессия активна
type PropertySessionUntil = time.Time

// User-Agent
type PropertyUserAgent = string

// Отображаемое имя пользователя
type PropertyUserDisplayName = string

// Электронная почта
type PropertyUserEmail = string

// Российский номер мобильного телефона в формате 9009009090
type PropertyUserPhoneTyped = string

// Тип пользователя из набора (admin|dispatcher|driver)
type PropertyUserType = string

// Номер телефона (в произвольной форме) или адрес электронной почты
type PropertyUsername = string

// ResetPasswordRequestBody defines model for resetPasswordRequestBody.
type ResetPasswordRequestBody struct {
	// Номер телефона (в произвольной форме) или адрес электронной почты
	Username PropertyUsername `form:"username" json:"username" validate:"required,min=3,max=255"`
}

// Возможный DeviceID если запрос пришёл от мобильного устройства
type DeviceId = PropertyDeviceId

// IP-адрес
type Ip = PropertyIP

// User-Agent
type UserAgent = PropertyUserAgent

// CheckResponseOK defines model for checkResponseOK.
type CheckResponseOK = CheckResponse

// LoginResponseOK defines model for loginResponseOK.
type LoginResponseOK = LoginResponse

// Данные отсутствуют
type ResponseNoContent = interface{}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "../common/schema.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
